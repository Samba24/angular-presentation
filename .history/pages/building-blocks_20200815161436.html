<h4 class="text-left mt-4 ml-4 heading">3 - Les éléments constitutifs d'Angular</h4>
<h5 class="text-left mt-4 ml-5 heading">3.1 - NgModules</h5>
<p>
    Les modules définissent un contexte d'exécution pour des composants spécifiques. A la creation d'un projet Angular avec la CLI un module de base
    (root module) est automatiquement créé et regroupe tous les éléments que l'on déclare dans notre application tel que les composants, les services ou les modules tiers.
    Les NgModules utilise le décorateur <code>@NgModule</code> et disposent de quatre arrays utilisés pour les inclusions que sont :
    <ul>
        <li><b>Declarations</b>
            <p>
                Regroupe tous les éléments susceptibles d'être utilisé dans nos templates tel que les composants, pipes et directives et qui sont uniquement visibles dans le module actuel (specific scope).
            </p>
        </li>
        <li><b>Providers</b>
            <p>
                On retrouve tous les services enregistrés dans notre module dans cet array.
            </p>
        </li>
        <li><b>Imports</b>
            <p>
                Regroupe tous les autres modules qui sont importés dans le module courant.
            </p>
        </li>
        <li><b>Bootstrap</b>
            <p>
                Permet de définir le composant de base (root component) lors du processus de bootstraping.
            </p>
        </li>
    </ul>
</p>
<h5 class="text-left mt-4 ml-5 heading">3.2 - Composants</h5>
<p>
    Les composants sont les pièces maîtresses d'une application Angular. Ils sont en charge de contrôler les templates en leur fournissant leurs données ainsi
    qu'en gérant toute la logique derrière ces derniers.<br>
    Les composants utilisent le décorateur <code>@Component</code> et sont associés à un template à leur creation.<br>
    On peut facilement créer un composant en utilisant la commande <code>ng generate component nom_du_composant</code> ou son raccourci
    <code>ng g c nom_du_composant</code>. On obtient ainsi les fichiers suivants dans un dossier portant le nom de notre composant sous le répertoire <kbd>app</kbd><br>
    
</p>
<div>
    <kbd class="">myComponent</kbd><br><br>
    <i class="fa fa-long-arrow-right ml-3 mr-2"></i><span class="component">myComponent.component.ts</span>
    <p class="ml-5">
        Correspond à notre composant en tant que tel, toute la logique permettant de piloter la vue se trouve dans ce fichier.
    </p>
    <i class="fa fa-long-arrow-right ml-3 mr-2"></i><span class="component">myComponent.component.spec.ts</span>
    <p class="ml-5">
        Permet d'écrire des tests sur notre composant à l'aide de Jasmine (optionnelle).
    </p>
    <i class="fa fa-long-arrow-right ml-3 mr-2"></i><span class="component">myComponent.component.css</span>
    <p class="ml-5">
        Permet de définir des styles CSS sur la vue associé a notre composant.
    </p>
    <i class="fa fa-long-arrow-right ml-3 mr-2"></i><span class="component">myComponent.component.html</span>
    <p class="ml-5">
        Représente la vue du composant, toute la partie présentation se trouve dans ce fichier.
    </p>
    <br>
</div>
<p>
    Les composants ont un cycle de vie (création,modification,supression).<br>
    A chaque étape du cycle de vie d'un composant, il est possible d'éffectuer des traitements spécificiques en utilisant les lifecycle hooks.<br>
    <center><img src="./images/lifecycle.png" alt="" srcset="" width="300px" height="300px"></center>
</p>
<h5 class="text-left mt-4 ml-5 heading">3.3 - Templates</h5>
<p>
    Les templates sont les pages HTML tel qu'on les connaît, un template est associé a un contrôleur (une classe composante) qui est 
    chargée de lui fournir des données et d'éxecuter certaines fonctions en réaction a un événement utilisateur (clic de bouton, envoi d'un formulaire).<br>
    Les informations circulent donc dans les deux sens à savoir du contrôleur vers la vue (<b>property binding</b>) et de la vue vers le contrôleur (<b>event binding</b>).<br>
    <!-- On retrouve généralement sur nos templates ce qu'on appele les <b>directives</b>. Les directives sont appliques sur nos balises HTML et
    permettent.<br>
    On retrouvera souvent sur les templates, les directives suivantes :
    <ul>
        <li>ngFor</li>
        <li>ngModel</li>
        <li>ngIf</li>
        <li>ngTemplateOutlet</li>
    </ul> -->
</p>
<h5 class="text-left mt-4 ml-5 heading">3.4 - Services</h5>
<p>
    Les services sont créés afin de rendre les contrôleurs plus clairs et moins lourds. Le but principal
    des services est d'interconnecter notre front avec le back en envoyant des requêtes HTTP permettant 
    de récupérer les données exposées par notre API. Les services sont recupérées par l'injecteur d'Angular 
    afin de pouvoir les utiliser facilement dans nos components par injéction de dépendance dans le constructeur
    de ces derniers.<br>
    Les services permettent aussi de faire certains traitements sur les données récupérées afin d'éviter de surcharger
    nos components avec beaucoup de logique.<br>
    On peut facilement créer un service à l'aide de la CLI avec la commande <code>ng g s nom_de_notre_service</code>.
</p>
<h5 class="text-left mt-4 ml-5 heading">3.5 - Routing</h5>
<p>
    Le routing consiste à associer une URL (path) à un component. La configuration des routes peut se faire dans le
    root module mais la bonne pratique consiste à créer un fichier spécifique de route <kbd>app.routing.ts</kbd> ou on va 
    créer toutes les routes de notre application.<br>
    Quand une route est défini dans ce fichier, si toutefois on entre l'URL de la route dans le navigateur, le composant 
    en charge est automatiquement instancié et sa vue retournée.<br>
    Angular dispose d'un systéme de guarding permettant de gérer l'accés à certaines routes. Les guardiens sont des classes
    qui implementent l'interface <code>CanActivate</code> et qui override la methode <code>canActivate</code> . Cette méthode retourne <code>true</code> si l'accés a été valide et <code>false</code>
    si l'accés a été refusé. Ce systéme de guarding permet de protéger les routes que l'on défini.<br>
    On peut créer un guard avec la commande <code>ng g g nom_du_guard</code>.
</p>
<h5 class="text-left mt-4 ml-5 heading">3.6 - Forms</h5>
<p>
    Angular dispose de deux maniéres de gérer les formulaires que sont :
    <ul>
        <li>Les Reactives Forms
            <p>
                Reactive Forms permet de gérer l'etat d'un formulaire.
                Ce type de formulaire est entiérement géré par le composant et sa définition même se fait dans le composant.<br>
                Angular dispose ainsi de classe permettant de représenter chaque control sur notre formulaire. Les données provenant du formulaire sont en temps réel
                injectées dans les variables correspondantes ce qui permet de representer tout l'etat de notre formulaire dans une seule variable en cas de besoin.<br>
                Des validations sont aussi directement appliquables sur les controls à la création du formulaire permettant a l'utilisateur d'avoir un live feedback de l'état du
                formulaire directement sur la vue.

            </p>
        </li>
        <li>Template driven Forms
            <p>
                A la différence des Reactive forms ou toute la déclaration des variables du formulaire se fait sur le composant, les Template driven forms
                manipulent les données du formulaire dans la vue (template variables) et utilisent la directive ngModel pour assurer la synchronisation des données entre le modéle
                et notre formulaire.<br>
                La directive ngModel est utilisée en two-way data binding ce qui veut dire que les données circulent dans les deux sens à savoir
                de notre modéle vers le formulaire et du formulaire vers notre modéle. Ce mécanisme permet d'avoir à chaque instant un modéle de données en synchro avec
                notre formulaire.<br>
                En ce qui concerne la validation du formulaire, on dispose de certaines classes qui sont automatiquement appliquées sur notre contrôle en fonction de l'état de la
                validation. Il s'agit de : 
                <ul>
                    <li>ng-untouched <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control n'a pas encore été touché</li>
                    <li>ng-touched <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control a été touché</li>
                    <li>ng-pristine <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control n'a pas encore été modifié</li>
                    <li>ng-dirty <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control a été modifié</li>
                    <li>ng-valid <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control est valide</li>
                    <li>ng-invalid <i class="fa fa-long-arrow-right mr-1" aria-hidden="true"></i> Le control n'est pas valide</li>
                </ul>
            </p>
        </li>
    </ul>
</p>
<div class="mb-5">
    <a href="#" target-page="building-blocks" id="next" class="next offset-10 ngColor"><i class="fa fa-arrow-circle-o-right mr-2"></i>Suivant</a>
</div>
